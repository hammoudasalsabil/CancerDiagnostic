mock==2.0.0
streamlit-0.79.0-py2.py3-none-any.whl


"""
Description     : Simple Python implementation of the Apriori Algorithm

Usage:
    $python apriori.py -f DATASET.csv -s minSupport  -c minConfidence

    $python apriori.py -f DATASET.csv -s 0.15 -c 0.6
"""

import sys
from PyPDF2 import PdfFileWriter, PdfFileReader
from io import BytesIO 
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from itertools import chain, combinations
from collections import defaultdict
from optparse import OptionParser

class apriory():
    def __init__(self, id):
        self.id_alert = id
        print('id form apriory --------', self.id_alert)
        optparser = OptionParser()
        optparser.add_option(
            "-f", "--inputFile", dest="input", help="filename containing csv", default=None
        )
        optparser.add_option(
            "-s",
            "--minSupport",
            dest="minS",
            help="minimum support value",
            default=0.9,
            type="float",
        )
        optparser.add_option(
            "-c",
            "--minConfidence",
            dest="minC",
            help="minimum confidence value",
            default=0.9,
            type="float",
        )

        (options, args) = optparser.parse_args()

        inFile = None
        if options.input is None:
            inFile = sys.stdin
        elif options.input is not None:
            inFile = self.dataFromFile(options.input)
        else:
            print("No dataset filename specified, system with exit\n")
            sys.exit("System will exit")

        minSupport = options.minS
        minConfidence = options.minC

        items, rules = self.runApriori(inFile, minSupport, minConfidence)

        self.printResults(items, rules)

    def subsets(arr):
        """ Returns non empty subsets of arr"""
        return chain(*[combinations(arr, i + 1) for i, a in enumerate(arr)])


    def returnItemsWithMinSupport(itemSet, transactionList, minSupport, freqSet):
        """calculates the support for items in the itemSet and returns a subset
        of the itemSet each of whose elements satisfies the minimum support"""
        _itemSet = set()
        localSet = defaultdict(int)

        for item in itemSet:
            for transaction in transactionList:
                if item.issubset(transaction):
                    freqSet[item] += 1
                    localSet[item] += 1

        for item, count in localSet.items():
            support = float(count) / len(transactionList)

            if support >= minSupport:
                _itemSet.add(item)

        return _itemSet


    def joinSet(itemSet, length):
        """Join a set with itself and returns the n-element itemsets"""
        return set(
            [i.union(j) for i in itemSet for j in itemSet if len(i.union(j)) == length]
        )


    def getItemSetTransactionList(self, data_iterator):
        transactionList = list()
        itemSet = set()
        for record in data_iterator:
            transaction = frozenset(record)
            transactionList.append(transaction)
            for item in transaction:
                itemSet.add(frozenset([item]))  # Generate 1-itemSets
        return itemSet, transactionList


    def runApriori(self, data_iter, minSupport, minConfidence):
        """
        run the apriori algorithm. data_iter is a record iterator
        Return both:
        - items (tuple, support)
        - rules ((pretuple, posttuple), confidence)
        """
        itemSet, transactionList = self.getItemSetTransactionList(data_iter)

        freqSet = defaultdict(int)
        largeSet = dict()
        # Global dictionary which stores (key=n-itemSets,value=support)
        # which satisfy minSupport

        assocRules = dict()
        # Dictionary which stores Association Rules

        oneCSet = self.returnItemsWithMinSupport(itemSet, transactionList, minSupport, freqSet)

        currentLSet = oneCSet
        k = 2
        while currentLSet != set([]):
            largeSet[k - 1] = currentLSet
            currentLSet = self.joinSet(currentLSet, k)
            currentCSet = self.returnItemsWithMinSupport(
                currentLSet, transactionList, minSupport, freqSet
            )
            currentLSet = currentCSet
            k = k + 1

        def getSupport(item):
            """local function which Returns the support of an item"""
            return float(freqSet[item]) / len(transactionList)

        toRetItems = []
        for key, value in largeSet.items():
            toRetItems.extend([(tuple(item), getSupport(item)) for item in value])

        toRetRules = []
        for key, value in list(largeSet.items())[1:]:
            for item in value:
                _subsets = map(frozenset, [x for x in self.subsets(item)])
                for element in _subsets:
                    remain = item.difference(element)
                    if len(remain) > 0:
                        confidence = getSupport(item) / getSupport(element)
                        if confidence >= minConfidence:
                            toRetRules.append(((tuple(element), tuple(remain)), confidence))
        return toRetItems, toRetRules


    def printResults(self, items, rules):
        """prints the generated itemsets sorted by support and the confidence rules sorted by confidence"""
        for item, support in sorted(items, key=lambda x: x[1]):
            print("item: %s , %.3f" % (str(item), support))
        print("\n------------------------ RULES:")

        packet = BytesIO()
        # create a new PDF with Reportlab
        can = canvas.Canvas(packet, pagesize=letter)
        sps = 20
        i = 0
        for rule, confidence in sorted(rules, key=lambda x: x[1]):
            pre, post = rule
            if post[0] == 'probability' and len(post)==1 :
                i= i + 1
                sps = sps + 20
                x = "Rule: %s ==> %s , %.3f" % (str(pre), str(post), confidence)
                text = "Rule %d: %s ==> %s " % (i, str(pre), str(post)) 
                
                can.drawString(50,550 - sps, text )
        can.save()

        #move to the beginning of the StringIO buffer
        packet.seek(0)
        new_pdf = PdfFileReader(packet)
        # read your existing PDF
        existing_pdf = PdfFileReader(open("filevide.pdf", "rb"))
        output = PdfFileWriter()
        # add the "watermark" (which is the new pdf) on the existing page
        page = existing_pdf.getPage(0)
        page.mergePage(new_pdf.getPage(0))
        output.addPage(page)
        # finally, write "output" to a real file
        filename = "Rules_{}.pdf"
        filename = filename.format(self.id_alert)
        outputfite = "C:/Users/Nour/CDApp/FrontEnd/CancerDiagnostic/src/assets/regles/" + filename
        outputStream = open(outputfite, "wb")
        output.write(outputStream)
        outputStream.close()

    def to_str_results(items, rules):
        """prints the generated itemsets sorted by support and the confidence rules sorted by confidence"""
        i, r = [], []
        for item, support in sorted(items, key=lambda x: x[1]):
            x = "item: %s , %.3f" % (str(item), support)
            i.append(x)

        for rule, confidence in sorted(rules, key=lambda x: x[1]):
            pre, post = rule
            if str(post) == 'probability':
                x = "Rule: %s ==> %s , %.3f" % (str(pre), str(post), confidence)
                r.append(x)
            
                
        return i, r


    def dataFromFile(fname):
        """Function which reads from the file and yields a generator"""
        with open(fname, "rU") as file_iter:
            for line in file_iter:
                line = line.strip().rstrip(",")  # Remove trailing comma
                record = frozenset(line.split(","))
                yield record
